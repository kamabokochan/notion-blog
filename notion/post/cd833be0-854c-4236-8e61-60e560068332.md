
## useContext


> _コンテクスト_を用いると、コンポーネントは props を渡すことなく、[離れた親要素から情報を取得できるようになります](https://ja.react.dev/learn/passing-props-to-a-component)。例えば、アプリの最上位のコンポーネントが、現在の UI テーマをコンポーネントの階層に関係なくすべてのコンポーネントに渡すことができます。

- バケツリレーによるpropsの受け渡し、それに伴う不要なコンポーネントの経由やレンダリングを行わないようにすることができる。

	**App.js**


	```typescript
	import { useContext } from 'react';
	
	function App() {
		const [theme, setTheme] = useState('dark')
		return (
			<ThemeContext.Provider value={theme}>
				// ...
			<ThemeContext.Provider>
		)
	}
	
	function MyComponent() {
		// コンポーネントのトップレベルでuseContextを呼び出し、サブスクライブする
	  const theme = useContext(ThemeContext);
	  // ...
	  
	```


	**context**


	```typescript
	import { createContext } from 'react';
	
	export const ThemeContext = createContext('dark');
	```


## 返り値

- 値はツリー内で`useContext`を呼び出したコンポーネントの上位かつ最も近い`SomeContext.Provider` に渡された `value` に決定される。
	- もし対象の値が見つからない場合は、 [`createContext`](https://ja.react.dev/reference/react/createContext) に渡した `defaultValue` になる。

## **ツリーの一部でコンテクストの値を上書きする（**[https://ja.react.dev/reference/react/useContext#overriding-context-for-a-part-of-the-tree](https://ja.react.dev/reference/react/useContext#overriding-context-for-a-part-of-the-tree)**）**

- 部分的に上書きをすることが可能

	```typescript
	<ThemeContext.Provider value="dark">
	  ...
	  <ThemeContext.Provider value="light">
	    <Footer />
	  </ThemeContext.Provider>
	  ...
	</ThemeContext.Provider>
	```


## **オブジェクトや関数を渡すときの再レンダーの最適化（**[https://ja.react.dev/reference/react/useContext#optimizing-re-renders-when-passing-objects-and-functions](https://ja.react.dev/reference/react/useContext#optimizing-re-renders-when-passing-objects-and-functions)**）**

- Contextには関数を渡すことも可能
	- コンポーネントが再レンダーされるたびに新しい関数を生成する → contextが更新されることでそれを呼び出している全てのコンポーネントが再レンダーされてしまう
		- → useCallbackやuseMemoを使って、不要な再生成を行わないように制御し、パフォーマンスを最適化する。

		```typescript
		function MyApp() {
		  const [currentUser, setCurrentUser] = useState(null);
		
		  function login(response) {
		    storeCredentials(response.credentials);
		    setCurrentUser(response.user);
		  }
		
		  return (
			  // loginという関数を渡すが、MyAppが再レンダーされるたびに、新しいlogin関数が生成されてしまう
		    <AuthContext.Provider value={{ currentUser, login }}>
		      <Page />
		    </AuthContext.Provider>
		  );
		}
		```


		以下のように最適化させる


		```typescript
		import { useCallback, useMemo } from 'react';
		
		function MyApp() {
		  const [currentUser, setCurrentUser] = useState(null);
		
			// useCallbackすることで、同じメモリアドレスを参照できる（ような感覚に近い）
		  const login = useCallback((response) => {
		    storeCredentials(response.credentials);
		    setCurrentUser(response.user);
		  }, []);
		
		  const contextValue = useMemo(() => ({
		    currentUser,
		    login
		  }), [currentUser, login]);
		
		  return (
		    <AuthContext.Provider value={contextValue}>
		      <Page />
		    </AuthContext.Provider>
		  );
		}
		```


## コンテクストを使う前に（[https://ja.react.dev/learn/passing-data-deeply-with-context#before-you-use-context](https://ja.react.dev/learn/passing-data-deeply-with-context#before-you-use-context)）

1. まずはpropsで渡す方法から始める
	- 簡潔に済む実装であれば、propsが最もシンプルで可読性が高い方法
2. 不要なレイヤーを削減し、コンポーネントの階層をなるべく少なくする
	- childrenをJSXとして渡す方法を検討する

		```typescript
		// ❌ Layoutは本来不要なpostsを子へ渡すためだけに、受け取っている
		<Layout posts={posts} />
		
		↓
		
		// ⭕️ childrenとしてJSXを受け取ることで、不要なpropsの受け渡しを行わなくて済む
		<Layout>
			<Posts posts={posts} />
		</Layout>
		```

3. コンテクストを検討する

## TypeScriptを活用した例

- Context

	```typescript
	import React, { createContext, useContext, useState, ReactNode } from 'react';
	
	// テーマの型定義
	type Theme = 'light' | 'dark';
	
	// コンテキストの型定義
	interface ThemeContextType {
	  theme: Theme;
	  toggleTheme: () => void;
	}
	
	// コンテキストの作成
	const ThemeContext = createContext<ThemeContextType | undefined>(undefined);
	
	// プロバイダーコンポーネントの作成
	const ThemeProvider = ({ children }: { children: ReactNode }) => {
	  const [theme, setTheme] = useState<Theme>('light');
	
	  const toggleTheme = () => {
	    setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'));
	  };
	
	  return (
	    <ThemeContext.Provider value={{ theme, toggleTheme }}>
	      {children}
	    </ThemeContext.Provider>
	  );
	};
	
	// useTheme フックの作成
	const useTheme = (): ThemeContextType => {
	  const context = useContext(ThemeContext);
	  if (!context) {
	    throw new Error('useTheme must be used within a ThemeProvider');
	  }
	  return context;
	};
	
	export { ThemeProvider, useTheme };
	
	```


	コンポーネント


	```typescript
	import React from 'react';
	import ReactDOM from 'react-dom';
	import { ThemeProvider } from './ThemeContext';
	import { ThemeToggleButton, ThemeDisplay } from './ThemeComponents';
	
	const App = () => {
	  return (
	    <ThemeProvider>
	      <div style={{ padding: '20px' }}>
	        <ThemeDisplay />
	        <ThemeToggleButton />
	      </div>
	    </ThemeProvider>
	  );
	};
	
	const ThemeDisplay = () => {
	  const { theme } = useTheme();
	
	  return <div>Current Theme: {theme}</div>;
	};
	
	const ThemeToggleButton = () => {
	  const { theme, toggleTheme } = useTheme();
	
	  return (
	    <button onClick={toggleTheme}>
	      Switch to {theme === 'light' ? 'Dark' : 'Light'} Mode
	    </button>
	  );
	};
	
	ReactDOM.render(<App />, document.getElementById('root'));
	```

