
## useMemo


> `useMemo` は、レンダー間で計算結果をキャッシュするための React フックです。


基本的に、高コストな計算の再実行などを避けたい場合に利用する。アプリケーションによっては全く利用しなくても問題ないケースもある。


```typescript
const cachedValue = useMemo(calculateValue, dependencies)
```

- calculateValue
	- キャッシュしたい値を計算する関数
	- 純関数であり、引数なし。必ず何か値をreturnする
	- Reactは初回レンダー時に、この関数を呼び出す
	- dependenciesが変化していなければ、同じ値を返す
	- dependenciesが変化していれば、calculateValueを再実行して結果を返す
		- 同時に、値の再利用のために、結果を保存しておく。
- dependencies
	- `calculateValue` のコード内で参照されているすべてのリアクティブ値の配列
		- リアクティブ値には、props、state、およびコンポーネント本体で直接宣言されているすべての変数と関数が含まれる。

## メモ化とは

- `useMemo`は、レンダー毎に繰り返す必要のない高コストな計算をスキップすることができる
	- 前回のレンダー時と同じ結果を返すだけなのであれば、`useMemo`でラップすることでキャッシュした値を返すことができる
	- → キャッシュのことを`メモ化`という
- 関数やオブジェクトは、毎回異なるものを生成する
	- 関数やオブジェクトを依存値に設定すると、毎回レンダーしてしまうため注意が必要
	- 関数のメモ化には[**`useCallback`**](https://ja.react.dev/reference/react/useCallback) を使う

## 計算コストが高いかどうかを見分ける方法（[https://ja.react.dev/reference/react/useMemo#how-to-tell-if-a-calculation-is-expensive](https://ja.react.dev/reference/react/useMemo#how-to-tell-if-a-calculation-is-expensive)）

- `console.time` を使って、実行にかかった時間を計測する方法がある

## メモ化が役立つアプリケーションとは（[https://ja.react.dev/reference/react/useMemo#should-you-add-usememo-everywhere](https://ja.react.dev/reference/react/useMemo#should-you-add-usememo-everywhere)）


> `useMemo` を利用した最適化が力を発揮するのは、以下のような、ほんの一部のケースに限られます。

- `useMemo` で行う計算が著しく遅く、かつ、その依存値がほとんど変化しない場合。
- 計算した値を、[`memo`](https://ja.react.dev/reference/react/memo) でラップされたコンポーネントの props に渡す場合。この場合は、値が変化していない場合には再レンダーをスキップしたいでしょう。メモ化することで、依存値が異なる場合にのみコンポーネントを再レンダーさせることができます。
- その値が、後で何らかのフックの依存値として使用されるケース。例えば、別の `useMemo` の計算結果がその値に依存している場合や、[`useEffect`](https://ja.react.dev/reference/react/useEffect) がその値に依存している場合などです。

上記以外のケースでは、メモ化のメリットはない。


可能な限り全てメモ化するというチームもあるが、可読性が下がってしまう欠点がある。


また、1つでも毎回変化する依存値が存在するだけで、コンポーネント全体のメモ化が無意味になる。


> **以下のいくつかの原則に従うことで、多くのメモ化を不要にすることができます**。

1. コンポーネントが他のコンポーネントを視覚的にラップするときは、それが[子として JSX を受け入れるようにします](https://ja.react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)。これにより、ラッパコンポーネントが自身の state を更新しても、React はその子を再レンダーする必要がないことを認識します。
2. ローカル state を優先し、必要以上に [state のリフトアップ](https://ja.react.dev/learn/sharing-state-between-components)を行わないようにします。フォームや、アイテムがホバーされているかどうか、といった頻繁に変化する state は、ツリーのトップやグローバルの状態ライブラリに保持しないでください。
3. [レンダーロジックを純粋に](https://ja.react.dev/learn/keeping-components-pure)保ちます。コンポーネントの再レンダーが問題を引き起こしたり、何らかの目に見える視覚的な結果を生じたりする場合、それはあなたのコンポーネントのバグです！ メモ化を追加するのではなく、バグを修正します。
4. [state を更新する不要なエフェクトを避けてください](https://ja.react.dev/learn/you-might-not-need-an-effect)。React アプリケーションのパフォーマンス問題の大部分は、エフェクト内での連鎖的な state 更新によってコンポーネントのレンダーが何度も引き起こされるために生じます。
5. [エフェクトから不要な依存値をできるだけ削除します](https://ja.react.dev/learn/removing-effect-dependencies)。例えば、メモ化する代わりに、オブジェクトや関数をエフェクトの中や外に移動させるだけで、簡単に解決できる場合があります。
