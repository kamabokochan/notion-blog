
## useEffect

- [`useEffect`](https://ja.react.dev/reference/react/useEffect) は外部のシステムとコンポーネントを接続します。
	- 外部システムと同期する必要がない場合、エフェクトはおそらく不要です。（[https://ja.react.dev/learn/you-might-not-need-an-effect](https://ja.react.dev/learn/you-might-not-need-an-effect)）

	```typescript
	useEffect(setup, dependencies?)
	```

	- `setup`
		- エフェクトのロジックを記述する関数
		- コンポーネントが初めてDOMに追加された時、セットアップ関数を実行する
		- `dependencies`が変更されると
			- （あれば）クリーンアップ関数を実行
			- 新しい値でセットアップ関数を実行
		- コンポーネントがDOMから削除された後、最後にもう一度クリーンアップ関数を実行する。
	- `dependencies` （省略可能）
		- コード内で参照される全てのリアクティブな値のリスト
			- **依存配列を渡す**

				```typescript
				useEffect(() => {
				  // ...
				}, [a, b]); // Runs again if a or b are different
				```

				- `setup`の実行タイミング
					- 初回のレンダー後
					- 依存配列が変わった後の再レンダー後
			- **空の依存配列を渡す**

				```typescript
				useEffect(() => {
				  // ...
				}, []); // Does not run again (except once in development)
				```

				- `setup`の実行タイミング
					- 初回のレンダー後
			- **依存配列を渡さない**

				```typescript
				useEffect(() => {
				  // ...
				}); // Always runs again
				```

				- `setup`の実行タイミング
					- コンポーネントの**毎回のレンダー（再レンダー）後に**エフェクトが実行される
		- 依存配列にコンポーネント内で定義されたオブジェクトや関数がある場合、必要以上にエフェクトを再実行する可能性があるため、その場合は該当の値を削除する。
- usage

	```typescript
	import { useEffect } from 'react';
	import { createConnection } from './chat.js';
	
	function ChatRoom({ roomId }) {
	  const [serverUrl, setServerUrl] = useState('https://localhost:1234');
	
	  useEffect(() => {
	    const connection = createConnection(serverUrl, roomId);
	    connection.connect();
	    return () => {
	      connection.disconnect();
	    };
	  }, [serverUrl, roomId]);
	  // ...
	}
	```


## 外部システムへの接続（[https://ja.react.dev/reference/react/useEffect#connecting-to-an-external-system](https://ja.react.dev/reference/react/useEffect#connecting-to-an-external-system)）

- ネットワーク、API、サードパーティライブラリとの接続など、外部との接続をするにはトップレベルで`useEffect` を呼び出す。
	- セットアップコード
		- システムに接続する
	- クリーンアップコード
		- システムから切断する

## カスタムフックにエフェクトをラップする（[https://ja.react.dev/reference/react/useEffect#wrapping-effects-in-custom-hooks](https://ja.react.dev/reference/react/useEffect#wrapping-effects-in-custom-hooks)）

- エフェクトを何度も書く必要があると気づいたら、**カスタムフックに抽出する必要があるというサイン**。

## 非Reactウィジェットの制御（[https://ja.react.dev/reference/react/useEffect#controlling-a-non-react-widget](https://ja.react.dev/reference/react/useEffect#controlling-a-non-react-widget)）

- 外部システム（サードパーティ製のウィジェットなど）をコンポーネントのstateやpropsに同期させたい時、エフェクトを使った制御が有効。

## データフェッチ（[https://ja.react.dev/reference/react/useEffect#fetching-data-with-effects](https://ja.react.dev/reference/react/useEffect#fetching-data-with-effects)）

- フレームワークを使用している場合は、エフェクトでフェッチするよりもフレームワークのデータフェッチメカニズムを使用するべき
- エフェクトに直接データフェッチを書くと、メンテナビリティが低くなるのでカスタムふっくにする
- エフェクトの競合状態を回避するには、フラグを使ったクリーンアップを使用する（[https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect)）

結論として、フェッチはライブラリに寄せたほうがよさそう


## **エフェクト内で以前の state に基づいて state を更新する（**[https://ja.react.dev/reference/react/useEffect#updating-state-based-on-previous-state-from-an-effect](https://ja.react.dev/reference/react/useEffect#updating-state-based-on-previous-state-from-an-effect)**）**

- state更新用関数を渡すことで、countを監視対象から取り除くことができる。（不要なレンダリングを回避できる）

```typescript
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const intervalId = setInterval(() => {
      // ❌ setCount(count + 1); // You want to increment the counter every second...
      setCount(c => c + 1); // ✅ Pass a state updater
    }, 1000)
    return () => clearInterval(intervalId);
  // ❌ }, [count]); // 🚩 ... but specifying `count` as a dependency always resets the interval.
  }, []); // ✅ Now count is not a dependency
  // ...
}
```


## **オブジェクト型の不要な依存値を削除する （**[https://ja.react.dev/reference/react/useEffect#removing-unnecessary-object-dependencies](https://ja.react.dev/reference/react/useEffect#removing-unnecessary-object-dependencies)**）**

- オブジェクトを監視対象とすると、レンダーごとに異なるためエフェクトが実行されてしまう
	- → エフェクトの中でオブジェクトを作成する

## 関数を依存値として使用することは避ける（[https://ja.react.dev/reference/react/useEffect#removing-unnecessary-function-dependencies](https://ja.react.dev/reference/react/useEffect#removing-unnecessary-function-dependencies)）

- 関数を依存値にすると、毎回のレンダー後にエフェクトが再実行されてしまう
	- → エフェクトの内部で宣言する

## **サーバとクライアントで異なるコンテンツを表示する（**[https://ja.react.dev/reference/react/useEffect#displaying-different-content-on-the-server-and-the-client](https://ja.react.dev/reference/react/useEffect#displaying-different-content-on-the-server-and-the-client)**）**

- クライアント側でハイドレーション（HTML にイベントハンドラをアタッチするために再度レンダーコードを実行）を行うため、初回レンダーがクライアントとサーバの両方で同一でなければならない理由
- `localStorage` からデータを読み込むなど、クライアント側で異なるレンダーを行いたいケースでは、useEffectでマウントフラグをコントロールする方法がある。

	```typescript
	function MyComponent() {
	  const [didMount, setDidMount] = useState(false);
	
	  useEffect(() => {
	    setDidMount(true);
	  }, []);
	
	  if (didMount) {
	    // ... return client-only JSX ...
	  }  else {
	    // ... return initial JSX ...
	  }
	}
	```

	- ただし、遅延表示によって体験が良くないため多用しないこと。

## 不要なエフェクトの削除（[https://ja.react.dev/learn/you-might-not-need-an-effect#how-to-remove-unnecessary-effects](https://ja.react.dev/learn/you-might-not-need-an-effect#how-to-remove-unnecessary-effects)）

- データ変換にはエフェクトは不要
	- コンポーネントのトップレベルでデータ変換を行う
	- propsやstateが変更されるたびに再実行される
- fullNameの計算にエフェクトは不要。
	- 既存の props や state から計算できるものは、レンダー中に計算する

	```typescript
	function Form() {
	  const [firstName, setFirstName] = useState('Taylor');
	  const [lastName, setLastName] = useState('Swift');
	
	  // 🔴 Avoid: redundant state and unnecessary Effect
	  const [fullName, setFullName] = useState('');
	  useEffect(() => {
	    setFullName(firstName + ' ' + lastName);
	  }, [firstName, lastName]);
	  // ...
	}
	```


	↓


	```typescript
	function Form() {
	  const [firstName, setFirstName] = useState('Taylor');
	  const [lastName, setLastName] = useState('Swift');
	  // ✅ Good: calculated during rendering
	  const fullName = firstName + ' ' + lastName;
	  // ...
	}
	```

- フィルタリングも同様にレンダーで計算する

	```typescript
	function TodoList({ todos, filter }) {
	  const [newTodo, setNewTodo] = useState('');
	  // ✅ This is fine if getFilteredTodos() is not slow.
	  const visibleTodos = getFilteredTodos(todos, filter);
	  // ...
	}
	```

	- ただし、大量のtodoを捌く際など不要な再計算を避けたい場合は、`useMemo` を利用する。

	```typescript
	import { useMemo, useState } from 'react';
	
	function TodoList({ todos, filter }) {
	  const [newTodo, setNewTodo] = useState('');
	  // ✅ Does not re-run getFilteredTodos() unless todos or filter change
	  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);
	  // ...
	}
	```


## **props が変更されたときにすべての state をリセットする （**[https://ja.react.dev/learn/you-might-not-need-an-effect#resetting-all-state-when-a-prop-changes](https://ja.react.dev/learn/you-might-not-need-an-effect#resetting-all-state-when-a-prop-changes)**）**

- 通常、React は同じコンポーネントが同じ場所でレンダーされるときに state を保持する
	- ユニークな `userId` を受け取ってユーザー毎に異なる内容をレンダーしても、`state` は古いユーザーの情報を保持している
		- useEffectによる監視と初期化は、不要なレンダーが多発するため非効率的である（古い値と新しい値で2回レンダーする）
	- `key` を使うことで、**state を共有すべきでない 2 つの異なるコンポーネントとして React に扱わせる**

		```typescript
		export default function ProfilePage({ userId }) {
		  return (
		    <Profile
		      userId={userId}
		      key={userId}
		    />
		  );
		}
		
		function Profile({ userId }) {
		  // ✅ This and any other state below will reset on key change automatically
		  const [comment, setComment] = useState('');
		  // ...
		}
		```


### 一部のstateのみ、リセットしたい場合（[https://ja.react.dev/learn/you-might-not-need-an-effect#adjusting-some-state-when-a-prop-changes](https://ja.react.dev/learn/you-might-not-need-an-effect#adjusting-some-state-when-a-prop-changes)）


> どのように行っても、props や他の state に基づいて state を調整すると、データフローが理解しにくくなり、デバッグが難しくなります。代わりに常に、[key ですべての state をリセット](https://ja.react.dev/learn/you-might-not-need-an-effect#resetting-all-state-when-a-prop-changes)できないか、[レンダー中にすべてを計算](https://ja.react.dev/learn/you-might-not-need-an-effect#updating-state-based-on-props-or-state)できないか、検討してください。

- 一部のstateのみをリセットすることは、複雑になるためそもそも避ける。
	- コンポーネントの構造自体を見直すか、全てをリセット or 計算などシンプルなロジックに寄せるほうがよい。

## **イベントハンドラ間でのロジックの共有（**[https://ja.react.dev/learn/you-might-not-need-an-effect#sharing-logic-between-event-handlers](https://ja.react.dev/learn/you-might-not-need-an-effect#sharing-logic-between-event-handlers)**）**


> **あるコードがエフェクトにあるべきか、イベントハンドラにあるべきかわからない場合は、そのコードが実行される**_**理由**_**を自問してください。**

- ページが表示された時に実行するべきなのか、どうかを軸に検討する
	- ボタンはページが表示された時ではなく、ボタンが押された時に実行されたい

## **アプリケーションの初期化（**[https://ja.react.dev/learn/you-might-not-need-an-effect#initializing-the-application](https://ja.react.dev/learn/you-might-not-need-an-effect#initializing-the-application)**）**

- 初期化処理を行うエフェクトは、開発環境だと2回実行される（strictMode）ため、問題が発生する可能性がある
	- 本番環境では1度だとしても、コードの移動や再利用性の観点から、フラグなどを使って1度のみ実行するように制御
		- 開発環境でも同様に動く
- 初期化ロジックは`App.js` のようなルートコンポーネントモジュールやアプリケーションのエントリーポイントに保持する

## **外部ストアへのサブスクライブ （**[https://ja.react.dev/learn/you-might-not-need-an-effect#subscribing-to-an-external-store](https://ja.react.dev/learn/you-might-not-need-an-effect#subscribing-to-an-external-store)**）**

- エフェクトでも良いが、 [`useSyncExternalStore`](https://ja.react.dev/reference/react/useSyncExternalStore) が推奨される

## **そのエフェクトは不要かも（まとめ）**

- レンダー中に計算できるものであれば、エフェクトは必要ない。
- 重たい計算をキャッシュするには、`useEffect` の代わりに `useMemo` を追加する。
- コンポーネントツリー全体の state をリセットするには、異なる `key` を渡す。
- prop の変更に応じて一部の state をリセットする場合、レンダー中に行う。
- コンポーネントが_表示_されたために実行されるコードはエフェクトに、それ以外はイベントハンドラに入れる。
- 複数のコンポーネントの state を更新する必要がある場合、単一のイベントで行うことが望ましい。
- 異なるコンポーネントの state 変数を同期しようと思った際は、常に state のリフトアップを検討する。
- エフェクトでのデータフェッチは可能だが、競合状態を回避するためにクリーンアップを実装する必要がある。
