
# テストの目的について


> ✍🏻 テストは直接的にはエンジニアのみが恩恵を受けそうに見えるが、エンジニアが安全・安心に開発できる環境を整えておくことは巡り巡ってサービスに関わる全ての人に恩恵がある。

- 品質の向上
	- バグや不具合の早期発見を行い、品質を高める
- リグレッション防止
	- 新規に機能を追加・変更した際に既存機能が正常に動作することを保証する
- 開発速度の向上
	- 開発者の動作確認やレビューにおけるコストの発生を抑える
	- 開発環境の心理的な安全性を高め、開発のハードルを下げる
- ドキュメンテーション
	- テストを見ただけでどのような機能があるのかを把握しやすい状態にする

## テストの種類について


### フロントエンドテストの種類


[こちら](https://zenn.dev/coconala/articles/f048377f314507#%E3%83%86%E3%82%B9%E3%83%88%E3%81%AE%E7%B2%92%E5%BA%A6%E3%81%AB%E7%9D%80%E7%9B%AE%E3%81%97%E3%81%9F%E3%83%86%E3%82%B9%E3%83%88%E5%88%86%E9%A1%9E)を参考に、粒度と対象による分類で検討してみる


**粒度に着目したテスト分類**


| 種類           | 粒度 |
| ------------ | -- |
| ユニットテスト      | 小  |
| インテグレーションテスト | 中  |
| E2Eテスト       | 大  |


**観点に着目したテスト分類**


| 種類              | 観点                             | 詳細                                                     |
| --------------- | ------------------------------ | ------------------------------------------------------ |
| ロジックテスト         | ビジネスロジックやデータ処理の正確性             | 関数やメソッドの動作が期待通りであるかを、正常・異常系や境界値で動作を確認する                |
| インタラクションテスト     | ユーザーの操作が期待通りの結果を生むか            | ボタンのクリック、フォームの入力、メニューの選択など、ユーザーインターフェースとのインタラクションを検証する |
| スナップショットテスト     | コンポーネントの出力が期待通りであるか            | コンポーネントの状態やプロパティに基づくレンダリング結果が変わらないかの定期的な比較             |
| ビジュアルリグレッションテスト | UIの変更による視覚的な差異を検出              | 画面のレイアウトやデザインの変更が正しく反映されているかを確認し、意図しない変更を防ぐ            |
| アクセシビリティテスト     | アプリケーションがアクセシビリティ基準を満たしているかを検証 | スクリーンリーダーの対応、キーボード操作のサポート、コントラスト比など、全てのユーザーが利用できるかを確認  |
| パフォーマンステスト      | アプリケーションの応答時間や負荷耐性を確認          | ページの読み込み時間、インタラクションの応答速度、大量データ処理時のパフォーマンスを測定           |
| クロスブラウザテスト      | 様々なブラウザやデバイスでの表示や動作を確認         | 異なるブラウザ間でのCSSの適用やJavaScriptの挙動、レスポンシブデザインの確認           |


これらは各粒度においても基本的に行うことができるため、各粒度（3種類）に対して、各観点（7種類）を掛け合わせた21種類のテストを行うことができる。


ただし、21種類すべてを網羅することは時間やコストの観点で現実的ではないため、一般的なテスト戦略（テスティングトロフィーなど）やプロジェクトの目的・ゴール、アプリケーションの性質やチームの状況などを考慮し


優先度を決めてテスト計画を立てていくと良いのではないかと思う。


## テストの選定


一般的なテスト戦略として有名なものが2つ挙げられる。

- テストピラミッド
- テスティングトロフィー

これらを選定するにあたり、以下のポイントに重点を置きたいと考えた。

- 機能単体より複雑に組み合わせた時の動作に対して安心感を得たい
- テスト開発におけるスピード・コストと信頼度(品質に対する自信)とのバランスを取りたい

結果的に、テスティングトロフィーがマッチしているのではないかと考えた。


### 初期フェーズにおけるテスト観点と粒度


初期フェーズにおける観点と粒度を検討する。


今回初期フェーズでは、0→1の開発となるため、


仕様の不安定さに対する柔軟性、限られた納期に対して求められるスピード感など


テスト開発に対して割けるコストは限られてくる。


これらの背景から、なるべく「早い・安い・美味い」というコスパの良いものを優先的に選定する。


以下の⭕️のついたものを優先的に対応し、それ以外は状況を見て柔軟に検討を進めたい。


| 観点              | 粒度                           |
| --------------- | ---------------------------- |
| ロジックテスト         | ユニットテスト⭕️
インテグレーションテスト⭕️
E2E |
| インタラクションテスト     | ユニットテスト⭕️
インテグレーションテスト⭕️
E2E |
| スナップショットテスト     | ユニットテスト
インテグレーションテスト
E2E     |
| ビジュアルリグレッションテスト | ユニットテスト
インテグレーションテスト
E2E     |
| アクセシビリティテスト     | ユニットテスト
インテグレーションテスト
E2E     |
| パフォーマンステスト      | ユニットテスト
インテグレーションテスト
E2E     |
| クロスブラウザテスト      | ユニットテスト
インテグレーションテスト
E2E     |


## テスト開発に使用するツール・フレームワーク選定

- テストライブラリ（Vitest）

## テスト開発の進行


### 大切にしたいルール


**考え方**

- 開発タスクの中には必ずセットでテスト実装も含める。その際、実装すべきテスト項目はチームで合意を取る。
	- 時間的猶予がない場合には、なるべくテスト実装自体を削るのではなく、抑えるべき最低限のテスト項目を検討し、対応することとしたい

**記法周り**

- 自然言語を意識し、テストケースから仕様を読み取れるよう意識する
	- 新規メンバーや1年後の自分が見てもすぐに理解できるようにする
- Arange-Act-Assert（AAA）パターンを使用することで、可読性や他のテストケースとの一貫性を担保する
	- ARRANGE（準備）
	- ACT（実行）
	- ASSERT（検証）

	```shell
	import {render, screen} from '@testing-library/react'
	import userEvent from '@testing-library/user-event'
	import '@testing-library/jest-dom'
	import Fetch from './fetch'
	
	test('loads and displays greeting', async () => {
	  // ARRANGE
	  render(<Fetch url="/greeting" />)
	
	  // ACT
	  await userEvent.click(screen.getByText('Load Greeting'))
	  await screen.findByRole('heading')
	
	  // ASSERT
	  expect(screen.getByRole('heading')).toHaveTextContent('hello there')
	  expect(screen.getByRole('button')).toBeDisabled()
	})
	```


### テストをいつ実行するのか

- PRを作成した際に、CI上で実行する（テストが通った場合のみ、mergeする）
