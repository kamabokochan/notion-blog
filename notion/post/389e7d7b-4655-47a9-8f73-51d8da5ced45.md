
## **useCallback**


> `useCallback` は、再レンダー間で関数定義をキャッシュできるようにする React フックです。


```typescript
const cachedFn = useCallback(fn, dependencies)
```

- fn
	- キャッシュしたい関数型の値
	- 任意の引数を取り、任意の値を返すことができる
	- 初回レンダー時には、関数をそのまま返す（呼び出さない）
		- 次回以降のレンダーでは、ひとつ前のレンダーから`dependencies` が変更されていなければ、再び同じ関数を返す。
- dependencies
	- `fn` コード内で参照されるすべてのリアクティブな値のリスト
		- リアクティブな値には、props、state、コンポーネント本体に直接宣言されたすべての変数および関数が含まれる
- 返り値
	- 初回のレンダー時、`useCallback` は渡された `fn` 関数を返す
	- その後のレンダー時には、前回のレンダーからすでに保存されている `fn` 関数を返すか（依存配列が変更されていない場合）、このレンダー時に渡された `fn` 関数を返す。

## コンポーネントの再レンダーをスキップする（[https://ja.react.dev/reference/react/useCallback](https://ja.react.dev/reference/react/useCallback)）

- `handleSubmit` を`ShippingForm` のpropsに渡している。

> **デフォルトでは、コンポーネントが再レンダーされると、React はその子要素すべてを再帰的に再レンダーします**。


また


> **JavaScript では、****`function () {}`** **または** **`() => {}`** **は常に**_**異なる**_**関数を作成します**。


レンダーする度に新しい関数`handleSubmit` を生成する。


`handleSubmit` をpropsとして受け取っている子コンポーネント`ShippingForm` も、毎回再レンダーされることになる。


```typescript
function ProductPage({ productId, referrer, theme }) {
  // Every time the theme changes, this will be a different function...
  function handleSubmit(orderDetails) {
    post('/product/' + productId + '/buy', {
      referrer,
      orderDetails,
    });
  }
  
  return (
    <div className={theme}>
      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}
      <ShippingForm onSubmit={handleSubmit} />
    </div>
  );
}
```

- `handleSubmit`を`useCallback` でラップすることで、`dependencies` 内の値が変更されない限り、キャッシュした関数を返す（前回のレンダー時と同様の関数を返す）
	- 余計な `ShippingForm` の再レンダーをスキップすることができる

```typescript
function ProductPage({ productId, referrer, theme }) {
  // Tell React to cache your function between re-renders...
  const handleSubmit = useCallback((orderDetails) => {
    post('/product/' + productId + '/buy', {
      referrer,
      orderDetails,
    });
  }, [productId, referrer]); // ...so as long as these dependencies don't change...

  return (
    <div className={theme}>
      {/* ...ShippingForm will receive the same props and can skip re-rendering */}
      <ShippingForm onSubmit={handleSubmit} />
    </div>
  );
}
```


## **useCallback と useMemo の関係（**[https://ja.react.dev/reference/react/useCallback#how-is-usecallback-related-to-usememo](https://ja.react.dev/reference/react/useCallback#how-is-usecallback-related-to-usememo)**）**


> その違いはキャッシュできる_内容_です。

- `useMemo` は、関数の呼び出し結果をキャッシュする
- `useCallback` は関数自体をキャッシュする

```typescript
import { useMemo, useCallback } from 'react';

function ProductPage({ productId, referrer }) {
  const product = useData('/product/' + productId);

	// 🙆 useMemoは、computeRequirements関数の実行結果をキャッシュする
  const requirements = useMemo(() => { // Calls your function and caches its result
    return computeRequirements(product);
  }, [product]);

	// 🙆 useCallbackはhandleSubmitという関数自体をキャッシュする
  const handleSubmit = useCallback((orderDetails) => { // Caches your function itself
    post('/product/' + productId + '/buy', {
      referrer,
      orderDetails,
    });
  }, [productId, referrer]);

  return (
    <div className={theme}>
      <ShippingForm requirements={requirements} onSubmit={handleSubmit} />
    </div>
  );
}
```


簡略的に書くと、以下のような関係になる。


```typescript
// Simplified implementation (inside React)
function useCallback(fn, dependencies) {
  return useMemo(() => fn, dependencies);
}
```


## **あらゆる場所に useCallback を追加すべきか？（**[https://ja.react.dev/reference/react/useCallback#should-you-add-usecallback-everywhere](https://ja.react.dev/reference/react/useCallback#should-you-add-usecallback-everywhere)**）**


`useCallback` で関数をキャッシュすることが有用なケース

- 関数をコンポーネントに props として渡すケース
- 関数が、後で何らかのフックの依存値として使用されるケース
	- 他の `useCallback` でラップされた関数がそれに依存している、または [`useEffect`](https://ja.react.dev/reference/react/useEffect) からこの関数に依存しているケース

これらのケース以外では、関数を`useCallback` でラップするメリットはない。


全ての関数をメモ化すると、可読性が下がる。


関連： 


## **メモ化されたコールバックからの state 更新（**[https://ja.react.dev/reference/react/useCallback#updating-state-from-a-memoized-callback](https://ja.react.dev/reference/react/useCallback#updating-state-from-a-memoized-callback)**）**

- 下記のようなケースでは、todosを依存値として指定している

```typescript
function TodoList() {
  const [todos, setTodos] = useState([]);

  const handleAddTodo = useCallback((text) => {
    const newTodo = { id: nextId++, text };
    setTodos([...todos, newTodo]);
  }, [todos]); // todosを依存値に指定
```

- 更新用関数を利用することで、依存値を完全に無くすことができる

```typescript
function TodoList() {
  const [todos, setTodos] = useState([]);

  const handleAddTodo = useCallback((text) => {
    const newTodo = { id: nextId++, text };
    setTodos(todos => [...todos, newTodo]); // 更新用関数
  }, []); // ✅ No need for the todos dependency
  // ...
```


## **エフェクトが頻繁に発火するのを防ぐ （**[https://ja.react.dev/reference/react/useCallback#preventing-an-effect-from-firing-too-often](https://ja.react.dev/reference/react/useCallback#preventing-an-effect-from-firing-too-often)**）**

- `useEffect` 内で、関数を呼び出したいというケースにおいて、関数を依存値に設定する必要がある
	- ただし、依存値に設定することで関数の不要な実行を招いてしまう

		```typescript
		// ❌ Bad
		function ChatRoom({ roomId }) {
		  const [message, setMessage] = useState('');
		
		  function createOptions() {
		    return {
		      serverUrl: 'https://localhost:1234',
		      roomId: roomId
		    };
		  }
		  
		  useEffect(() => {
		    const options = createOptions(); // エフェクトが実行されるたびに、関数が実行される（チャットルームへの再接続が繰り返される）
		    const connection = createConnection();
		    connection.connect();
		    return () => connection.disconnect();
		  // 関数はレンダーされるたびに、新しく生成される（前回の関数とは別物）ためエフェクトが実行される
		  }, [createOptions]); // 🔴 Problem: This dependency changes on every render
		  // ...
		```

- 関数を`useCallback` でラップすることで、同じ関数だと保証される

	```typescript
	// ✅ Better
	function ChatRoom({ roomId }) {
	  const [message, setMessage] = useState('');
	
	  const createOptions = useCallback(() => {
	    return {
	      serverUrl: 'https://localhost:1234',
	      roomId: roomId
	    };
	  // roomIdが同じ場合は、createOptionsはキャッシュした関数を返す
	  }, [roomId]); // ✅ Only changes when roomId changes
	
	  useEffect(() => {
	    const options = createOptions();
	    const connection = createConnection();
	    connection.connect();
	    return () => connection.disconnect();
	  }, [createOptions]); // ✅ Only changes when createOptions changes
	  // ...
	```

- 最も良い方法
	- 依存値に設定しないこと → 関数をエフェクトの内部へ移動する

		```typescript
		// ✅ Best
		function ChatRoom({ roomId }) {
		  const [message, setMessage] = useState('');
		
		  useEffect(() => {
			  // エフェクトの内部に移動することで、依存値に指定する必要がなくなる
		    function createOptions() { // ✅ No need for useCallback or function dependencies!
		      return {
		        serverUrl: 'https://localhost:1234',
		        roomId: roomId
		      };
		    }
		
		    const options = createOptions();
		    const connection = createConnection();
		    connection.connect();
		    return () => connection.disconnect();
		  }, [roomId]); // ✅ Only changes when roomId changes
		  // ...
		```


## **カスタムフックの最適化（**[https://ja.react.dev/reference/react/useCallback#optimizing-a-custom-hook](https://ja.react.dev/reference/react/useCallback#optimizing-a-custom-hook)**）**


> あなたが[カスタムフック](https://ja.react.dev/learn/reusing-logic-with-custom-hooks)を書いている場合、それが返すあらゆる関数は `useCallback` でラップすることが推奨されます。

