
## **useReducer**


> `useReducer` は、[リデューサ (reducer)](https://ja.react.dev/learn/extracting-state-logic-into-a-reducer) をコンポーネントに追加するための React フックです。

- リデューサとは（[https://ja.react.dev/learn/extracting-state-logic-into-a-reducer](https://ja.react.dev/learn/extracting-state-logic-into-a-reducer)）
	- stateの管理が煩雑になってきた場合に有効な手段
	- stateの更新に関するロジックを別の関数に切り出す（リデューサ関数）

例：useStateでタスクをタスク管理アプリを作成する場合

- 各イベントハンドラでstateを更新しており、処理が煩雑かつ変更を加えにくい状態に。

	```typescript
	import { useState } from 'react';
	import AddTask from './AddTask.js';
	import TaskList from './TaskList.js';
	
	export default function TaskApp() {
	  const [tasks, setTasks] = useState(initialTasks);
	
	  function handleAddTask(text) {
	    setTasks([
	      ...tasks,
	      {
	        id: nextId++,
	        text: text,
	        done: false,
	      },
	    ]);
	  }
	
	  function handleChangeTask(task) {
	    setTasks(
	      tasks.map((t) => {
	        if (t.id === task.id) {
	          return task;
	        } else {
	          return t;
	        }
	      })
	    );
	  }
	
	  function handleDeleteTask(taskId) {
	    setTasks(tasks.filter((t) => t.id !== taskId));
	  }
	
	  return (
	    <>
	      <h1>Prague itinerary</h1>
	      <AddTask onAddTask={handleAddTask} />
	      <TaskList
	        tasks={tasks}
	        onChangeTask={handleChangeTask}
	        onDeleteTask={handleDeleteTask}
	      />
	    </>
	  );
	}
	
	let nextId = 3;
	const initialTasks = [
	  {id: 0, text: 'Visit Kafka Museum', done: true},
	  {id: 1, text: 'Watch a puppet show', done: false},
	  {id: 2, text: 'Lennon Wall pic', done: false},
	];
	
	```

- useReducerにする
	- 各イベントハンドラから呼ばれるstateを更新させる関数では、`dispatch` が呼ばれており、 “イベントハンドラで「tasks をセットする」のではなく、「タスクを追加/変更/削除した」というアクションのディスパッチ“を行う。

	```typescript
	import { useReducer } from 'react';
	import AddTask from './AddTask.js';
	import TaskList from './TaskList.js';
	
	export default function TaskApp() {
	  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
	
		// 追加（add）したい
	  function handleAddTask(text) {
	    dispatch({
	      type: 'added',
	      id: nextId++,
	      text: text,
	    });
	  }
	
		// 変更（change）したい
	  function handleChangeTask(task) {
	    dispatch({
	      type: 'changed',
	      task: task,
	    });
	  }
	
		// 削除(delete)したい
	  function handleDeleteTask(taskId) {
	    dispatch({
	      type: 'deleted',
	      id: taskId,
	    });
	  }
	
	  return (
	    <>
	      <h1>Prague itinerary</h1>
	      <AddTask onAddTask={handleAddTask} />
	      <TaskList
	        tasks={tasks}
	        onChangeTask={handleChangeTask}
	        onDeleteTask={handleDeleteTask}
	      />
	    </>
	  );
	}
	
	// dispatchされた時、各アクションごとにどのようにstateを更新させるかというロジックのコアの部分は、tasksReducer　という関数に分離される。
	// これは「tasksReducer.ts」のように、ファイル自体を分けることも可能。
	// stateを更新させたい側と、実際に更新させるロジック部分の関心を分離できる。
	function tasksReducer(tasks, action) {
	  switch (action.type) {
	    case 'added': {
	      return [
	        ...tasks,
	        {
	          id: action.id,
	          text: action.text,
	          done: false,
	        },
	      ];
	    }
	    case 'changed': {
	      return tasks.map((t) => {
	        if (t.id === action.task.id) {
	          return action.task;
	        } else {
	          return t;
	        }
	      });
	    }
	    case 'deleted': {
	      return tasks.filter((t) => t.id !== action.id);
	    }
	    default: {
	      throw Error('Unknown action: ' + action.type);
	    }
	  }
	}
	
	let nextId = 3;
	const initialTasks = [
	  {id: 0, text: 'Visit Kafka Museum', done: true},
	  {id: 1, text: 'Watch a puppet show', done: false},
	  {id: 2, text: 'Lennon Wall pic', done: false},
	];
	
	```


## useReducer


```typescript
import { useReducer } from 'react';

// reducer関数
function reducer(state, action) {
  // ...
}

function MyComponent() {
	// reducer reducer関数
	// initialArg 初期state
	// init 初期stateを返す初期化関数。指定されていない場合の初期stateはinitialArgそのものになる。
  const [state, dispatch] = useReducer(reducer, initialArg, init);
  // ...
```


## **初期 state の再作成を避ける（**[https://ja.react.dev/reference/react/useReducer#avoiding-recreating-the-initial-state](https://ja.react.dev/reference/react/useReducer#avoiding-recreating-the-initial-state)**）**

- useReducerの第三引数には、関数の実行結果ではなく、関数自体を渡す。
	- リレンダリングのたびに関数を呼び出すため、不要なコストが発生する

	```typescript
	function createInitialState(username) {
	  // ...
	}
	
	function TodoList({ username }) {
	  // ❌
	  const [state, dispatch] = useReducer(reducer, createInitialState(username));
	  
	  // ⭕️
	  const [state, dispatch] = useReducer(reducer, username, createInitialState);
	  // ...
	```


## useState vs useReducer（[https://ja.react.dev/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer](https://ja.react.dev/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer)）

- コードサイズ
	- 一般的には、useStateの方が少ないが、コードがより複雑化するとuseReducerの方が少なくなりやすい。
- 可読性
	- シンプルなロジックのみであれば、useStateの方が読みやすいが、複雑化するとuseReducerの方がロジックの流れを追いやすい。
- デバッグ
	- useStateは多用されると、バグの調査が難しい。
	- useReducerの方が、ロジックを負いやすいため、バグの調査がしやすい。
- テスト
	- useReducerはリデューサを純関数として切り出せるので、テストを書きやすい。

## 良いリデューサ

- 純関数であること
	- 複雑なロジックを含めないこと。
	- オブジェクトや配列を書き換えずに、更新する。
	- 通常、stateを書き換えてはいけないが、`Immer`では特別なdraftオブジェクトを提供しており、これを書き換えることは可能。
- 複数のデータ更新を伴うアクションであっても、単一のユーザ操作を記述する
	- フォームの例：5つのフィールドをリセットする場合
		- ❌：`set_field`アクションを5回ディスパッチする
		- ⭕️：`reset_form`アクションを1回ディスパッチする
	- リデューサのアクションログは、ユーザの操作やレスポンスの順序を毎回全く同じように再現することはできないため。
		- バグが起きたとしても再現性が低く、修正が難しい状況になりやすい。

## TypeScriptを活用した例


```typescript
import React, { useReducer } from 'react';

// 1. 状態の型定義
interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

type State = Todo[];

// 2. アクションの型定義
type Action =
  | { type: 'ADD_TODO'; payload: string }
  | { type: 'TOGGLE_TODO'; payload: number }
  | { type: 'REMOVE_TODO'; payload: number };

// 3. リデューサー関数の型定義
const todoReducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TODO':
      return [
        ...state,
        {
          id: state.length + 1,
          text: action.payload,
          completed: false,
        },
      ];
    case 'TOGGLE_TODO':
      return state.map((todo) =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    case 'REMOVE_TODO':
      return state.filter((todo) => todo.id !== action.payload);
    default:
      return state;
  }
};

// 4. useReducerの使用
const TodoApp: React.FC = () => {
  const [state, dispatch] = useReducer(todoReducer, []);

  const addTodo = (text: string) => {
    dispatch({ type: 'ADD_TODO', payload: text });
  };

  const toggleTodo = (id: number) => {
    dispatch({ type: 'TOGGLE_TODO', payload: id });
  };

  const removeTodo = (id: number) => {
    dispatch({ type: 'REMOVE_TODO', payload: id });
  };

  return (
    <div>
      <button onClick={() => addTodo('Learn TypeScript')}>Add Todo</button>
      <ul>
        {state.map((todo) => (
          <li key={todo.id}>
            <span
              style={{
                textDecoration: todo.completed ? 'line-through' : 'none',
              }}
              onClick={() => toggleTodo(todo.id)}
            >
              {todo.text}
            </span>
            <button onClick={() => removeTodo(todo.id)}>Remove</button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default TodoApp;

```

